<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        var MARKER_DIAMETER_METERS = 250;
        var REPEAT_MODE = false;
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Down East flooding map locations</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
    <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        * {
            margin: 0; 
            padding: 0;
            font-family: "Aptos", sans-serif;
        }

        #map {
            height: 100vh;
            width: 70vw;
            float: left;
        }
        #controls {
            width: 28vw;
            float: right;
            padding-left: 1vw;
            padding-right: 1vw;
            padding-top: 1vh;
            padding-bottom: 1vh;
            height: 98vh;
            overflow-y: scroll;
            background-color: rgb(254, 254, 254);
        }
        #export-btn {
            margin: 10px;
            padding: 5px 10px;
            color: white;
            border: none;
        }
        #export-btn.enabled {
            background-color: #337ab7;
            cursor: pointer;
        }
        #export-btn.disabled {
            background-color: #aaa;
            cursor: default;
        }
        #labels-table {
            width: 100%;
            border-collapse: collapse;
            cursor: pointer;
        }
        #labels-table th, #labels-table td {
            border: 1px solid #ccc;
            padding: 6px;
            text-align: left;
        }
        #labels-table th {
            border: none;
        }
        #labels-table td {
            border: none;
        }
        #labels-table tr {
            border-bottom: 1px solid #444;
        }
        #help {
            color:rgb(2, 133, 199);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <button id="export-btn" class="disabled" disabled="disabled">Export places</button>
        <small id="help">Help...</small>
        <table id="labels-table">
            <thead>
                <tr>
                    <th>Place</th>
                    <th>Options</th>
                    <th>Done</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    <!-- Modal for circle label input -->
    <div id="labelModal" class="modal fade" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enter label for the marker</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="labelForm">
                        <div class="form-group">
                            <label for="circleLabel">Label</label>
                            <input type="text" class="form-control" id="circleLabel" name="circleLabel" required>
                        </div>
                        <div class="form-group">
                            <label>Options</label><br>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="optionA" value="A">
                                <label class="form-check-label" for="optionA">A</label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="optionB" value="B">
                                <label class="form-check-label" for="optionB">B</label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="optionC" value="C">
                                <label class="form-check-label" for="optionC">C</label>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal" id="cancelButton">Cancel</button>
                    <button type="submit" class="btn btn-primary" form="labelForm">Submit</button>
                </div>
            </div>
        </div>
    </div>


    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
    <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js'></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="mousetrap.js"></script>    

    <script>
        var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            // maxZoom: 18,
        });

        var Esri_WorldTopoMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
            // attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
        });

        var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            // attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        var USGS_USImageryTopo = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 20,
            attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
        });

        var defaultView = {
            center: [34.80158464213949, -76.66000448289184],
            zoom: 10
        };

        var map = L.map('map',{
            center: defaultView.center,
            zoom: defaultView.zoom,
            layers: [Esri_WorldTopoMap]
        });
        map.setMinZoom(10);
        map.attributionControl.remove();

        var baseMaps = {
            "ESRI Topo": Esri_WorldTopoMap,
            "ESRI Imagery": Esri_WorldImagery,
            "OpenStreetMap": osm,
            "USGS Hybrid": USGS_USImageryTopo
        };

        var layerControl = L.control.layers(baseMaps)
        layerControl.options.position = "bottomright";

        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        var drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems
            },
            draw: {
                polygon: false,
                polyline: false,
                rectangle: false,
                circle: {
                    shapeOptions: {
                        color: 'red'
                    },
                    repeatMode: REPEAT_MODE
                },
                marker: false,
                circlemarker: false
            }
        });
        map.addControl(drawControl);

        var clickStyle =  {
            fillColor: "#00ff00",
            color: "#00ff00",
            weight: 3,
            opacity: 1,
            fillOpacity: 0.2,
        }

        var unclickStyle = {
            fillColor: "#ff0000",
            color: "#ff0000",
            weight: 3,
            opacity: 1,
            fillOpacity: 0.2,
        }

        function clickOnMarker(e){
            if (e.target.feature.properties.clicked) {
                e.target.setStyle(unclickStyle);
                e.target.feature.properties.clicked = false;
            } else {
                e.target.setStyle(clickStyle);
                e.target.feature.properties.clicked = true;
            }
            updateLabelsTable();
        }

        var label_counter = 1;
        var currentLayer = null; // To keep track of the current layer

        map.on('draw:created', function (e) {
            var layer = e.layer;
            if (e.layerType === 'circle') {
                currentLayer = layer; // Store the layer
                document.getElementById('labelModal').style.display = 'block'; // Show the modal
            }
        });

        // Modal handling
        var modal = $('#labelModal');
        var currentLayer = null;

        map.on('draw:created', function (e) {
            var layer = e.layer;
            if (e.layerType === 'circle') {
                currentLayer = layer; // Store the layer
                modal.modal('show'); // Show the modal using Bootstrap
            }
        });

        modal.on('shown.bs.modal', function (e) {
            $("#circleLabel").focus();
        });

        modal.on('hidden.bs.modal', function () {
            currentLayer = null; // Reset the current layer when the modal is hidden
        });

        $('#labelForm').on('submit', function (event) {
            event.preventDefault();
            var label = document.getElementById("circleLabel").value;
            var options = [];
            if (document.getElementById("optionA").checked) options.push("A");
            if (document.getElementById("optionB").checked) options.push("B");
            if (document.getElementById("optionC").checked) options.push("C");

            label = label_counter.toString() + ": " + label;
            label_counter++;
            currentLayer.bindTooltip(label, { 
                permanent: true,
                direction: 'top'
            }).openTooltip();
            currentLayer.feature = {
                type: 'Feature',
                properties: {
                    label: label,
                    options: options,
                    clicked: false
                }
            };
            currentLayer.on('click', clickOnMarker);
            currentLayer.setStyle(unclickStyle);
            drawnItems.addLayer(currentLayer);
            updateLabelsTable();
            currentLayer.setRadius(MARKER_DIAMETER_METERS);
            modal.modal('hide'); // Hide the modal using Bootstrap
        });


        // Table handling
        map.on('draw:editstop', function () {
            updateLabelsTable();
        }).on('draw:deletestop', function () {
            updateLabelsTable();
        });

        function updateLabelsTable() {
            var labels = [];
            drawnItems.eachLayer(function (layer) {
                if (layer.feature && layer.feature.properties.label) {
                    labels.push({
                        label: layer.feature.properties.label,
                        options: layer.feature.properties.options,
                        layer: layer
                    });
                }
            });

            var tableBody = document.querySelector('#labels-table tbody');
            tableBody.innerHTML = '';

            labels.forEach(function (item) {
                var row = document.createElement('tr');
                var labelCell = document.createElement('td');
                labelCell.textContent = item.label;
                var optionsCell = document.createElement('td');
                optionsCell.textContent = item.options.join(", ");
                var checkboxCell = document.createElement('td');
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = item.layer.feature.properties.clicked;
                checkbox.addEventListener('change', function() {
                    item.layer.feature.properties.clicked = checkbox.checked;
                    if (checkbox.checked) {
                        item.layer.setStyle(clickStyle);
                    } else {
                        item.layer.setStyle(unclickStyle);
                    }
                });
                checkboxCell.appendChild(checkbox);
                row.appendChild(labelCell);
                row.appendChild(optionsCell);
                row.appendChild(checkboxCell);
                tableBody.appendChild(row);

                row.addEventListener('click', function() {
                    map.setView(item.layer.getLatLng(), 14);
                    item.layer.openTooltip();
                });
            });

            // Update the counter on the export button
            if (labels.length > 0) {
                var button = document.getElementById('export-btn');
                button.textContent = `Export ${labels.length} places`;
                button.classList = "enabled";
                button.disabled = false;
            } else {
                var button = document.getElementById('export-btn');
                button.textContent = `Export places`;
                button.classList = "disabled";
                button.disabled = true;
            }
        }


        // Export handling
        function exportList() {
            if (drawnItems.getLayers().length == 0) {return false}

            var ready = true;
            drawnItems.getLayers().forEach((l) => {
                if(!l.feature.properties.clicked){
                    ready = false;
                }
            });
            if (!ready) {
                alert("There are still unverified places!");
                return false;
            }

            var data = drawnItems.toGeoJSON();
            var blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            var url = URL.createObjectURL(blob);

            var respondent = prompt("Respondent ID");
            var a = document.createElement('a');
            a.href = url;
            a.download = 'markers_'+respondent+'.geojson';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }

        document.getElementById('export-btn').addEventListener('click', exportList);

        window.onbeforeunload = function() {
            return "Are you sure you want to leave this page?";
        };

        var geocode_layers = [];

        // Add the geocoder control
        var geocoder = L.Control.geocoder({
            defaultMarkGeocode: false,
            geocoder: new L.Control.Geocoder.nominatim({
                geocodingQueryParams: {
                    viewbox: '-76,35,-77,34',
                    bounded: 1
                }
            }),
            collapsed: false
        }).on('markgeocode', function(e) {
            _removeGeocodeLayers();
            var bbox = e.geocode.bbox;
            var poly = L.polygon([
                bbox.getSouthEast(),
                bbox.getNorthEast(),
                bbox.getNorthWest(),
                bbox.getSouthWest()
            ]).addTo(map);
            map.fitBounds(poly.getBounds());
            map.setZoom(map.getZoom() - 1);
            geocode_layers.push(poly);
        }).addTo(map);

        function _removeGeocodeLayers() {
            geocode_layers.forEach((l) => {l.remove()});
        }

        layerControl.addTo(map);

        function _toDefaultView() {
            map.setView(defaultView.center, defaultView.zoom);
        }

        // Custom control to reset map view
        var resetControl = L.Control.extend({
            options: {
                position: 'topleft'
            },

            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                container.style.backgroundColor = 'white';     
                container.style.width = '30px';
                container.style.height = '30px';
                container.style.cursor = 'pointer';
                container.style.textAlign = 'center';
                container.style.lineHeight = '30px';
                container.style.fontSize = '1.7em';
                container.title = 'Reset map view';
                container.innerHTML = '&#x21bb;'; // Reset icon (you can customize this)

                container.onclick = function() {
                    _toDefaultView();
                };

                return container;
            }
        });

        map.addControl(new resetControl());

        // Hotkeys
        Mousetrap.bind(['r'], function(e) {
            _toDefaultView();
            return false;
        });

        Mousetrap.bind(['g'], function(e) {
            geocoder.getContainer().getElementsByTagName("input")[0].focus()
            return false;
        });

        Mousetrap.bind(['c'], function(e) {
            document.getElementsByClassName("leaflet-draw-draw-circle")[0].click()
            return false;
        });

        Mousetrap.bind(['e'], function(e) {
            exportList();
            return false;
        });

        Mousetrap.bind(['esc'], function(e) {
            _toDefaultView();
            _removeGeocodeLayers();
            return false;
        });

        // Help
        document.getElementById("help").onclick = function () {
            alert("Always export before reloading! \n[c] Place new circle \n[r] Reset map view \n[g] Focus on geocoder \n[e] Export geodata");
        }
    </script>
</body>
</html>
