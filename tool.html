<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        var MARKER_DIAMETER_METERS = 250;
        var REPEAT_MODE = false;
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Down East flooding map locations</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
    <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <style>
        * {margin: 0; padding: 0;}

        #map {
            height: 100vh;
            width: 70vw;
            float: left;
        }
        #controls {
            font-family: "Aptos", sans-serif;
            width: 28vw;
            float: right;
            padding-left: 1vw;
            padding-right: 1vw;
            padding-top: 1vh;
            padding-bottom: 1vh;
            height: 98vh;
            overflow-y: scroll;
        }
        #export-btn {
            margin: 10px;
            padding: 5px 10px;
            color: white;
            border: none;
        }
        #export-btn.enabled {
            background-color: #337ab7;
            cursor: pointer;
        }
        #export-btn.disabled {
            background-color: #aaa;
            cursor: default;
        }
        #labels-table {
            width: 100%;
            border-collapse: collapse;
            cursor: pointer;
        }
        #labels-table th, #labels-table td {
            border: 1px solid #ccc;
            padding: 6px;
            text-align: left;
        }
        #labels-table th {
            border: none;
        }
        #labels-table td {
            border: none;
        }
        #labels-table tr {
            border-bottom: 1px solid #444;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <button id="export-btn" class="disabled" disabled="disabled">Export places</button>
        <table id="labels-table">
            <thead>
                <tr>
                    <th>Place</th>
                    <th>Done</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
    <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js'></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>    

    <script>
        var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            // maxZoom: 18,
        });

        var Esri_WorldTopoMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
            // attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
        });

        var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            // attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        var map = L.map('map',{
            center: [34.80158464213949, -76.66000448289184], 
            zoom: 10,
            layers: [Esri_WorldTopoMap]
        });
        map.setMinZoom(10);

        var baseMaps = {
            "OpenStreetMap": osm,
            "ESRI Topo": Esri_WorldTopoMap,
            "ESRI Imagery": Esri_WorldImagery
        };

        var layerControl = L.control.layers(baseMaps).addTo(map);

        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        var drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems
            },
            draw: {
                polygon: false,
                polyline: false,
                rectangle: false,
                circle: {
                    shapeOptions: {
                        color: 'red'
                    },
                    repeatMode: REPEAT_MODE
                },
                marker: false,
                circlemarker: false
            }
        });
        map.addControl(drawControl);

        var clickStyle =  {
            fillColor: "#00ff00",
            color: "#00ff00",
            weight: 3,
            opacity: 1,
            fillOpacity: 0.2,
        }

        var unclickStyle = {
            fillColor: "#ff0000",
            color: "#ff0000",
            weight: 3,
            opacity: 1,
            fillOpacity: 0.2,
        }

        function clickOnMarker(e){
            if (e.target.feature.properties.clicked) {
                e.target.setStyle(unclickStyle);
                e.target.feature.properties.clicked = false;
            } else {
                e.target.setStyle(clickStyle);
                e.target.feature.properties.clicked = true;
            }
            updateLabelsTable();
        }

        var label_counter = 1;

        map.on('draw:created', function (e) {
            var layer = e.layer;
            if (e.layerType === 'circle') {
                var label = prompt('Enter label for the marker:');
                label = label_counter.toString() + ": " + label;
                label_counter++;
                layer.bindTooltip(label, { permanent: true }).openTooltip();
                layer.feature = {
                    type: 'Feature',
                    properties: {
                        label: label,
                        clicked: false
                    }
                };
                layer.on('click', clickOnMarker);
                layer.setStyle(unclickStyle);
                drawnItems.addLayer(layer);
                updateLabelsTable();
                layer.setRadius(MARKER_DIAMETER_METERS);
            }
        });

        map.on('draw:editstop', function () {
            updateLabelsTable();
        }).on('draw:deletestop', function () {
            updateLabelsTable();
        });

        function updateLabelsTable() {
            var labels = [];
            drawnItems.eachLayer(function (layer) {
                if (layer.feature && layer.feature.properties.label) {
                    labels.push({
                        label: layer.feature.properties.label,
                        layer: layer
                    });
                }
            });

            // labels.sort((a, b) => a.label.localeCompare(b.label));

            var tableBody = document.querySelector('#labels-table tbody');
            tableBody.innerHTML = '';

            labels.forEach(function (item) {
                var row = document.createElement('tr');
                var labelCell = document.createElement('td');
                labelCell.textContent = item.label;
                var checkboxCell = document.createElement('td');
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = item.layer.feature.properties.clicked;
                checkbox.disabled = true; // Make the checkbox read-only
                checkboxCell.appendChild(checkbox);
                row.appendChild(labelCell);
                row.appendChild(checkboxCell);
                tableBody.appendChild(row);

                row.addEventListener('click', function() {
                    map.setView(item.layer.getLatLng(), 13);
                    item.layer.openTooltip();
                    // item.layer.setStyle(clickStyle);
                    // item.layer.feature.properties.clicked = true;
                    updateLabelsTable();
                });
            });

            // Update the counter on the export button
            if (labels.length > 0) {
                var button = document.getElementById('export-btn');
                button.textContent = `Export ${labels.length} places`;
                button.classList = "enabled";
                button.disabled = false;
            } else {
                var button = document.getElementById('export-btn');
                button.textContent = `Export places`;
                button.classList = "disabled";
                button.disabled = true;
            }
        }

        function exportList() {
            var data = drawnItems.toGeoJSON();
            var blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            var url = URL.createObjectURL(blob);

            var a = document.createElement('a');
            a.href = url;
            a.download = 'markers.geojson';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }

        document.getElementById('export-btn').addEventListener('click', exportList);

        window.onbeforeunload = function() {
            // return exportList();
            return "Are you sure you want to leave this page?";
        };

        var geocode_layers = [];

        // Add the geocoder control
        var geocoder = L.Control.geocoder({
            defaultMarkGeocode: false,
            geocode: function(query, cb, context) {
                var modifiedQuery = query + " Carteret County, North Carolina, USA";
                L.Control.Geocoder.nominatim().geocode(modifiedQuery, cb, context);
            }
        }).on('markgeocode', function(e) {
            geocode_layers.forEach((l) => {l.remove()});
            var bbox = e.geocode.bbox;
            var poly = L.polygon([
                bbox.getSouthEast(),
                bbox.getNorthEast(),
                bbox.getNorthWest(),
                bbox.getSouthWest()
            ]).addTo(map);
            // map.panTo(poly.getCenter());
            map.fitBounds(poly.getBounds());
            map.setZoom(map.getZoom() - 1);
            geocode_layers.push(poly);
        }).addTo(map);
    </script>
</body>
</html>